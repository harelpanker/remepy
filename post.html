<!DOCTYPE html>
<html dir="ltr" lang="en">
  <head>
    <title>Post page elements</title>
    <meta charset="UTF-8" />

    <link rel="stylesheet" href="src/post.css" />
  </head>

  <body>
    <main>
      <section>
        <div class="container-article container">
          <div class="article-top">
            <span>2 min</span>
            <span class="dot"></span>
            <span>Nutrition</span>
          </div>
          <article class="container">
            <h2>Title h2</h2>
            <p>
              <strong
                >A more sophisticated means of detecting deadlocks is
                matrix-based algorithms.</strong
              >
              These create a
              <a
                href="https://cv.panker.dev/"
                target="_blank"
                rel="noopener noreferrer"
                >matrix</a
              >
              that displays available instances of each resource type, resource
              requests, and <i>resource allocations</i>.
            </p>
            <h3>Title h3</h3>
            <p>
              A more sophisticated means of detecting deadlocks is matrix-based
              algorithms. These create a matrix that displays available
              instances of each resource type, resource requests, and resource
              allocations.
            </p>
            <h4>Title h4</h4>
            <p>
              A more sophisticated means of detecting deadlocks is matrix-based
              algorithms. These create a matrix that displays available
              instances of each resource type, resource requests, and resource
              allocations.
            </p>
            <figure>
              <img
                src="public/post/one-contant.png"
                alt=""
                width="343"
                height="193"
              />
              <figcaption>The importance of staying well-hydrated.</figcaption>
            </figure>
            <ul>
              <li>
                <strong>Lack of encryption</strong>: By default, Kubernetes
                stores Secrets in unencrypted form within Etcd – which means
                that anyone who can access Etcd (such as anyone with a user
                account and sufficient permissions on the Kubernetes control
                plane node, which hosts Etcd) can read Secrets, unless admins
                turn on encryption.
              </li>
              <li>
                <strong>Access control complexity</strong>: Managing access
                configurations for Secrets can be challenging because you have
                to define access permissions for each resource separately.
              </li>
              <li>
                <strong>Secrets injection complexity</strong>: Exposing Secrets
                to applications as environment variables or volumes doesn’t
                always work well.
              </li>
            </ul>

            <ol>
              <li>
                <strong>Lack of encryption</strong>: By default, Kubernetes
                stores Secrets in unencrypted form within Etcd – which means
                that anyone who can access Etcd (such as anyone with a user
                account and sufficient permissions on the Kubernetes control
                plane node, which hosts Etcd) can read Secrets, unless admins
                turn on encryption.
              </li>
              <li>
                <strong>Access control complexity</strong>: Managing access
                configurations for Secrets can be challenging because you have
                to define access permissions for each resource separately.
              </li>
              <li>
                <strong>Secrets injection complexity</strong>: Exposing Secrets
                to applications as environment variables or volumes doesn’t
                always work well.
              </li>
            </ol>
          </article>
        </div>
      </section>
    </main>
  </body>
</html>
